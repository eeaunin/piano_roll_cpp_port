# Piano Roll C++ Port – Session Handover (2025-11-30T00:00:00Z)

This file summarizes the current state of the C++20 Dear ImGui piano roll port
(`piano_roll_cpp_port`) relative to the Python DearPyGUI implementation in
`../dpg_piano_roll`, and outlines the main remaining work for the next session.

## Current Status (High-Level)

- Core model and coordinates
  - `Note` and `NoteManager` implemented with:
    - CRUD operations.
    - Per-key spatial index.
    - Selection flags and a `selected_ids()` helper.
    - Snapshot-based undo/redo stacks.
  - `CoordinateSystem` implements:
    - Tick ↔ world and key ↔ world transforms.
    - World ↔ screen transforms aligned with the Python virtual viewport.
    - Bitwig-style horizontal scrolling (X can be negative), clamped vertical
      scroll with `max_scroll_y()`.
    - Pixels-per-beat / key zoom, ruler height, piano-key width.

- Grid and snapping
  - `GridSnapSystem` ports the Python `GridSnapSystem`:
    - Fixed set of divisions: 1/64…4 bars, same ticks as Python.
    - `SnapMode` (Off, Adaptive, Manual).
    - `snap_tick`, `snap_tick_floor`, `snap_tick_ceil`.
    - `magnetic_snap` used by `PointerTool::apply_snap` to emulate
      `magnetic_snap_tick`, with Shift disabling snapping.
    - `grid_lines` and `ruler_labels` for rendering.
  - Widget UI:
    - Snap mode combo (Off/Adaptive/Manual).
    - Snap division combo (1/64…4 bars) wired to `GridSnapSystem`.

- Rendering (`PianoRollRenderer` + overlays)
  - Background & grid:
    - Full background fill.
    - Piano-key strip rendered per key with `white_key_color`/`black_key_color`.
    - Grid area “zebra” key rows (lighter for white, darker for black keys).
    - Grid lines for measures, beats, and subdivisions with distinct colours and
      thicknesses.
    - Ruler rendering with labels from `GridSnapSystem::ruler_labels`.
  - Notes:
    - Rectangles clamped to the grid area.
    - Selected vs non-selected colours.
    - Double borders for selected notes:
      - Outer border in `selected_note_border_color`.
      - Inner inset border in `selected_note_inner_border_color`.
    - Simple drop shadow behind non-selected notes to approximate the Python
      z-depth look.
    - Note name labels (e.g. `C4`) on notes when zoomed in:
      - Displayed only when note height and width are large enough.
      - Positioned from original X and vertically centred, similar to the Python
        implementation, and clipped if off-screen.
  - Piano keys & labels:
    - Piano strip per key (white/black).
    - Left label column with note names + octaves:
      - Zoom-dependent density: all notes vs. only C/F vs. only C.
      - Horizontal C-lines under C rows, matching `_render_piano_keys_to`.
    - Piano-key hover/press highlight driven by `PianoRollWidget` state.
  - Selection & overlays:
    - `RenderSelectionOverlay` draws:
      - Selection rectangle clipped to the grid area.
      - Edge/body hover highlight based on `PointerTool::hover_state()`.
      - Drag preview overlays for all selected notes while dragging/resizing,
        colour-coded for move vs duplicate (blue vs green preview).
    - Spotlight band:
      - Horizontal band behind the extents of selected notes.
      - White vertical edge lines at the selection boundaries.
  - Playhead & clip boundaries:
    - Playhead as vertical line plus triangle handle at the top of the ruler.
    - Optional auto-scroll based on `playhead_auto_scroll` and margin in
      `PianoRollRenderConfig`, analogous to `PlaybackIndicator.should_auto_scroll`.
    - Clip boundaries via `[`, `]` brackets in the ruler at
      `clip_start_tick_`/`clip_end_tick_`.
  - Debug overlays:
    - Vertical cursor line (white) following mouse X (debug flag).
    - Clicked-cell highlight: grid cell (beat + key) stored in world/tick/key
      and rendered as a translucent rectangle in the grid, mirroring
      `last_clicked_cell`.

- Interaction (`PointerTool`, `KeyboardController`, widget)
  - `PointerTool`:
    - Click to select notes (with Ctrl/Shift multi-selection behaviour).
    - Drag to move notes:
      - If the clicked note is selected, the entire selection moves by the same
        delta (group drag).
      - Time movement uses magnetic snapping (honouring Shift to disable).
    - Drag near edges to resize notes:
      - Uses `apply_snap` to snap left/right edges.
      - Updates `default_note_duration_` so double-click creation inherits
        last edited length.
    - Drag in empty space to start rectangle selection:
      - Rectangle stored in world coords; selection remains consistent while
        scrolling.
      - Modes:
        - Plain drag: replace selection with notes inside rect.
        - Ctrl+drag: add mode (union of original selection and rect contents).
        - Shift+drag: toggle mode (notes in rect are toggled vs original).
    - Double-click to create/delete:
      - Double-click on a note: deletes it.
      - Double-click in empty grid: creates a new note snapped via magnetic
        snapping, with length from `default_note_duration_`.
    - Ctrl+drag duplication:
      - If Ctrl is held when pressing on a note and duplication is enabled,
        duplicates the current selection and drags the duplicates; originals
        remain unchanged.
    - Hover tracking:
      - Maintains `HoverState` with note id and edge/body classification.
  - Keyboard:
    - `KeyboardController`:
      - Ctrl+A: select all.
      - Delete/Backspace: delete selected notes (with undo).
      - Ctrl+C/Ctrl+V: copy/paste selected notes.
      - Ctrl+Z/Ctrl+Y: undo/redo via `NoteManager`.
      - Arrow keys (snap-aware):
        - Up/Down: move selected notes by semitones, or octaves with Shift.
        - Left/Right: move by current snap division (ticks) or a fine 1/128
          note step with Shift, using `GridSnapSystem` ticks and `ticks_per_beat`.
    - `PianoRollWidget::ensure_selected_notes_visible` keeps moved notes in view
      after keyboard moves (port of `_ensure_selected_notes_visible`).
  - Ruler & note-name interactions:
    - Ruler:
      - Click+drag in ruler area:
        - Horizontal pan gesture (predominantly X delta) pans without clamping X.
        - Zoom gesture (predominantly Y delta) zooms horizontally around an
          anchor beat, preserving the beat under the mouse.
      - Adjusts explored area to match Bitwig infinite timeline semantics.
    - Note-names (left label area):
      - Vertical pan gesture (predominantly Y delta) pans in pitch, clamped
        via `max_scroll_y()`.
      - Horizontal gesture (predominantly X delta) zooms vertically around an
        anchor Y/key, with 60–125% limits of base key height.
  - Scrollbar:
    - Custom horizontal scrollbar (`CustomScrollbar`) with:
      - Bitwig-style explored area semantics.
      - Drag-only thumb behaviour plus edge-resize zoom.
      - Double-click to fit view to clip boundaries, matching the Python
        `_handle_scrollbar_double_click`.
    - `PianoRollWidget` mirrors the Python `_expand_explored_area`,
      `_update_explored_area_for_notes`, and edge-resize handler math.
  - CC lanes:
    - Data: `ControlLane` and `ControlPoint`.
    - Rendering: `RenderControlLane` draws lane background, curve, and points.
    - Editing in widget:
      - Click to create a point (snapped to grid).
      - Drag to move point in time and value.
      - Ctrl+click near point to delete.
    - Multi-lane support with a simple CC lane selector.

## Known Gaps vs Python Implementation

These are the main remaining areas where behaviour may still diverge from the
latest Python implementation (especially `unified_piano_roll_main.py`,
`render_system.py`, and the playback modules).

- Layered rendering and z-order
  - Current C++ renderer uses a single ImGui drawlist pass rather than the
    multi-layer/double-buffered render system from `render_system.py`.
  - Note rendering does not yet incorporate z-index sorting or per-note
    brightness variation based on z-order (only a simple shadow for
    non-selected notes).
  - Loop and playback markers (from `loop_marker_rectangle.py` and
    `playback_markers.py`) are not yet ported.

- Playback integration
  - We have a simple playhead line+handle and optional auto-scroll, but there is
    no full playback engine:
    - No tempo/timebase-based tick advancement.
    - No loop markers / cue markers.
    - No marker dragging logic.
  - The Python `PlaybackIndicator` and `PlaybackMarkers` classes are partially
    represented visually but not behaviourally.

- Magnetic snap nuances
  - `PointerTool::apply_snap` uses `GridSnapSystem::magnetic_snap` with a fixed
    pixel range, and respects Shift to disable snapping.
  - However, the Python implementation also considers custom config for the
    magnetic range and uses `magnetic_snap_tick` in several preview paths
    (drag/resize preview, CC editing preview). The C++ side currently applies
    magnetic snapping only in note drag/resize and double-click creation, not
    in every preview path.

- Selection & interaction subtleties
  - Rectangle selection:
    - C++ currently supports Replace / Add (Ctrl) / Toggle (Shift) modes.
    - Python also has a “subtract” mode that is not mapped here.
  - Duplicate indicator overlay:
    - Python draws a special overlay when Ctrl is held over a note (duplicate
      mode preview). The C++ overlay currently just uses colour-coded drag
      previews; there is no separate duplicate indicator glyph.
  - Some extreme edge cases (e.g. selection while edge-scrolling, interaction
    during playback) may behave slightly differently because we don’t yet have
    the full `InteractionSystem` and per-mode state machine.

- Multi-window / multi-canvas support
  - The C++ port is a single-canvas, single-window implementation.
  - Python has multi-window/multi-layer experiments (`multi_window_layer_manager`,
    `multi_canvas` variants) which are out of scope for now, but worth noting.

- Performance & stress behaviour
  - C++ rendering and interaction should be performant, but we have not yet
    tuned for extreme note counts, heavy CC data, or large multi-bar clips
    under constant playback updates.

## Suggested Next Steps for the Next Session

These are concrete directions for a follow-up GPT-5 session to move toward a
full 1:1 behaviour match.

1. **Playback and loop markers**
   - Port `LoopMarkerRectangle` from `loop_marker_rectangle.py` into C++ on top
     of `DraggableRectangle` (similar to `CustomScrollbar`).
   - Add fields to `PianoRollWidget` for loop marker state (start/end ticks,
     enabled flag).
   - Render loop region bar and optional markers in the ruler layer, following
     `render_system.py` / `piano_roll_rendering.py`.
   - Integrate with playhead auto-scroll (e.g. `PlaybackIndicator.should_auto_scroll`).

2. **Layered rendering refactor**
   - Introduce C++ equivalents of:
     - `BackgroundLayerRenderer`
     - `NotesLayerRenderer`
     - `UILayerRenderer`
     - `OverlayLayerRenderer`
     - `DebugLayerRenderer`
   - Restructure `PianoRollRenderer::render` into smaller functions or classes
     that clearly separate:
     - Background (keys, zebra rows, grid).
     - Notes and note labels/shadows.
     - UI (ruler markers, clip boundaries, loop markers).
     - Overlay (selection rect, drag previews).
     - Debug (cursor line, clicked-cell highlight).
   - Keep using a single ImGui drawlist but mirror the logical ordering and
     responsibilities of the Python `render_system`.

3. **Fine-grained snapping and preview parity**
   - Audit all uses of snapping in the Python code:
     - Note drag previews.
     - Resize previews.
     - CC edit previews.
   - Ensure the C++ pointers (drag offsets, preview rectangles) use the same
     combination of `snap_tick_floor`, `snap_tick`, and `magnetic_snap`.
   - Consider adding a small helper on C++ side analogous to the Python
     `magnetic_snap_tick` wrapper to centralize this logic.

4. **Interaction edge cases and polish**
   - Compare `mouse_core_handlers.py`, `interaction_handlers.py`, and
     `interaction_system.py` against the current `PointerTool` / widget logic.
   - Check:
     - Drag thresholds before starting a move vs. click (the C++ logic is
       simpler here).
     - Exact edge-hit behaviour for resize (thresholds, handles).
     - Deselect-on-click on empty space behaviour vs. rectangle selection start.
   - Port any missing small behaviours (e.g. “pending toggle on release”
     semantics if important for parity).

5. **Config / theme alignment**
   - The Python code has a detailed colour scheme derived from the clip colour.
     The C++ port currently hard-codes a neutral theme.
   - Next step: expose a small helper that, given a “clip colour,” computes
     note fill/border, selected note colours, grid and ruler colours to
     approximate `UnifiedPianoRoll._update_colors_from_clip_color`.

6. **Targeted parity tests**
   - Create a small manual parity checklist:
     - Same pointer gestures (click, drag, resize, rectangle select, duplicate)
       produce identical note sets and positions for a small test clip.
     - Same scroll/zoom sequences (ruler pan/zoom, scrollbar edge-resize,
       note-name zoom) give equivalent viewport positions/ticks.
   - For each, compare C++ behaviour against the Python version using equivalent
     inputs (even if visual comparison must be done manually later).

## How to Continue from Here

For the next GPT-5 instance:

- Use this file plus `docs/PLAN.md` as your primary “where we are” reference.
- Cross-reference with the Python modules:
  - `unified_piano_roll_main.py` and `piano_roll_interaction.py` for interaction.
  - `render_system.py` and `piano_roll_rendering.py` for rendering and overlays.
  - `loop_marker_rectangle.py`, `playback_indicator.py`,
    `playback_markers.py` for playback UI.
- Stay focused on **behaviour parity** rather than inventing new UX; the user’s
  requirement is a 1:1 translation of the carefully tuned Python implementation.

